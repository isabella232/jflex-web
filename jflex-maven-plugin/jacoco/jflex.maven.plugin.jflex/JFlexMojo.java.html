<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JFlexMojo.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JFlex Maven Plugin</a> &gt; <a href="index.source.html" class="el_package">jflex.maven.plugin.jflex</a> &gt; <span class="el_source">JFlexMojo.java</span></div><h1>JFlexMojo.java</h1><pre class="source lang-java linenums">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * JFlex Maven3 plugin                                                     *
 * Copyright (c) 2007-2017  Régis Décamps &lt;decamps@users.sf.net&gt;           *
 * All rights reserved.                                                    *
 *                                                                         *
 * License: BSD                                                            *
 *                                                                         *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
package jflex.maven.plugin.jflex;

import static com.google.common.base.Strings.isNullOrEmpty;

import com.google.common.base.Predicate;
import com.google.common.collect.FluentIterable;
import com.google.common.collect.ImmutableSet;
import com.google.common.io.Files;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import jflex.core.OptionUtils;
import jflex.generator.LexGenerator;
import jflex.option.Options;
import org.apache.maven.plugin.AbstractMojo;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugin.MojoFailureException;
import org.apache.maven.plugins.annotations.LifecyclePhase;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;
import org.apache.maven.project.MavenProject;

/**
 * Generates lexical scanners from one or more &lt;a href=&quot;http://jflex.de/&quot;&gt;JFlex&lt;/a&gt; grammar files.
 *
 * @author Régis Décamps (decamps@users.sf.net)
 */
<span class="pc bpc" id="L41" title="1 of 2 branches missed.">@Mojo(name = &quot;generate&quot;, defaultPhase = LifecyclePhase.GENERATE_SOURCES, threadSafe = false)</span>
<span class="fc" id="L42">public class JFlexMojo extends AbstractMojo {</span>
  /** Name of the directory where to look for jflex files by default. */
  private static final String SRC_MAIN_JFLEX = &quot;src/main/jflex&quot;;

  @Parameter(property = &quot;project&quot;, required = true, readonly = true)
  private MavenProject project;

  // cannot use {@value SRC_MAIN_JFLEX} because Maven site goals.html
  // is kept raw.
  /**
   * List of grammar definitions to run the JFlex parser generator on. Each path may either specify
   * a single grammar file or a directory. Directories will be recursively scanned for files with
   * one of the following extensions: &quot;.jflex&quot;, &quot;.flex&quot;, &quot;.jlex&quot; or &quot;.lex&quot;. By default, all files in
   * {@code src/main/jflex} will be processed.
   *
   * @see #SRC_MAIN_JFLEX
   */
  @Parameter private File[] lexDefinitions;

  /** Name of the directory into which JFlex should generate the parser. */
  @Parameter(defaultValue = &quot;${project.build.directory}/generated-sources/jflex&quot;)
  private File outputDirectory;

  /**
   * The granularity in milliseconds of the last modification date for testing whether a source
   * needs regeneration.
   */
  @Parameter(property = &quot;lastModGranularityMs&quot;, defaultValue = &quot;0&quot;)
  private int staleMillis;

  /** Whether source code generation should be verbose. */
  @Parameter(defaultValue = &quot;false&quot;)
  private boolean verbose;

  /** Whether a warning will be logged when there are unused macros. */
  @Parameter(defaultValue = &quot;true&quot;)
  private boolean unusedWarning;

  /** Whether to dump full debug information. */
  @Parameter(defaultValue = &quot;false&quot;)
  private boolean dump;

  /**
   * Whether to produce graphviz .dot files for the generated automata. This feature is
   * EXPERIMENTAL.
   */
  @Parameter(defaultValue = &quot;false&quot;)
  private boolean dot;

  /** Use external skeleton file. */
  @Parameter private File skeleton;

  /** Strict JLex compatibility. */
  @Parameter(defaultValue = &quot;false&quot;)
  private boolean jlex;

  /** The generation method to use for the scanner. The only valid value is {@code pack}. */
<span class="fc" id="L99">  @Parameter(defaultValue = &quot;pack&quot;)</span>
  private String generationMethod = &quot;pack&quot;; // NOPMD

  /** A flag whether to perform the DFA minimization step during scanner generation. */
<span class="fc" id="L103">  @Parameter(defaultValue = &quot;true&quot;)</span>
  private boolean minimize = true; // NOPMD

  /**
   * A flag whether to enable the generation of a backup copy if the generated source file already
   * exists.
   */
<span class="fc" id="L110">  @Parameter(defaultValue = &quot;true&quot;)</span>
  private boolean backup = true; // NOPMD

  /**
   * If true, the dot (.) metachar matches [^\n] instead of [^\n\r\u000B\u000C\u0085\u2028\u2029].
   */
<span class="fc" id="L116">  @Parameter(defaultValue = &quot;false&quot;)</span>
  private boolean legacyDot = false; // NOPMD

  /**
   * The name of the character encoding for reading lexer specifications. Uses JVM default encoding
   * if unset.
   */
<span class="fc" id="L123">  @Parameter(defaultValue = &quot;&quot;)</span>
  private String encodingName = &quot;&quot;; // NOPMD

  /**
   * Generate java parsers from lexer definition files.
   *
   * &lt;p&gt;This methods is checks parameters, sets options and calls JFlex.Main.generate()
   */
  public void execute() throws MojoExecutionException, MojoFailureException {
<span class="fc" id="L132">    this.outputDirectory = getAbsolutePath(this.outputDirectory);</span>

    // compiling the generated source in target/generated-sources/ is
    // the whole point of this plugin compared to running the ant plugin
<span class="fc" id="L136">    project.addCompileSourceRoot(outputDirectory.getPath());</span>

    List&lt;File&gt; filesIt;
<span class="pc bpc" id="L139" title="1 of 2 branches missed.">    if (lexDefinitions == null) {</span>
      // use default lexfiles if none provided
<span class="nc" id="L141">      getLog().debug(&quot;Use lexer files found in (default) &quot; + SRC_MAIN_JFLEX);</span>
<span class="nc" id="L142">      filesIt = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L143">      File defaultDir = getAbsolutePath(new File(SRC_MAIN_JFLEX));</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">      if (defaultDir.isDirectory()) {</span>
<span class="nc" id="L145">        filesIt.add(defaultDir);</span>
      }
<span class="nc" id="L147">    } else {</span>
      // use arguments provided in the plugin configuration
<span class="fc" id="L149">      filesIt = Arrays.asList(lexDefinitions);</span>

<span class="fc" id="L151">      getLog()</span>
<span class="fc" id="L152">          .debug(</span>
              &quot;Parsing &quot;
                  + lexDefinitions.length
                  + &quot; jflex files or directories given in configuration&quot;);
    }
    // process all lexDefinitions
<span class="fc bfc" id="L158" title="All 2 branches covered.">    for (File lexDefinition : filesIt) {</span>
<span class="fc" id="L159">      lexDefinition = getAbsolutePath(lexDefinition);</span>
<span class="fc" id="L160">      parseLexDefinition(lexDefinition);</span>
<span class="fc" id="L161">    }</span>
<span class="fc" id="L162">  }</span>

  /**
   * Generates java code of a parser from a lexer file.
   *
   * &lt;p&gt;If the {@code lexDefinition} is a directory, process all lexer files contained within.
   *
   * @param lexDefinition Lexer definiton file or directory to process.
   * @throws MojoFailureException if the file is not found.
   * @throws MojoExecutionException if file could not be parsed
   */
  private void parseLexDefinition(File lexDefinition)
      throws MojoFailureException, MojoExecutionException {
<span class="pc bpc" id="L175" title="2 of 4 branches missed.">    assert lexDefinition.isAbsolute() : lexDefinition;</span>

<span class="fc bfc" id="L177" title="All 2 branches covered.">    if (lexDefinition.isDirectory()) {</span>
      // recursively process files contained within
<span class="fc" id="L179">      getLog().debug(&quot;Processing lexer files found in &quot; + lexDefinition);</span>
      FluentIterable&lt;File&gt; files =
<span class="fc" id="L181">          Files.fileTreeTraverser()</span>
<span class="fc" id="L182">              .preOrderTraversal(lexDefinition)</span>
<span class="fc" id="L183">              .filter(new ExtensionPredicate(&quot;jflex&quot;, &quot;jlex&quot;, &quot;lex&quot;, &quot;flex&quot;));</span>
<span class="fc bfc" id="L184" title="All 2 branches covered.">      for (File lexFile : files) {</span>
<span class="fc" id="L185">        parseLexFile(lexFile);</span>
<span class="fc" id="L186">      }</span>
<span class="fc" id="L187">    } else {</span>
<span class="fc" id="L188">      parseLexFile(lexDefinition);</span>
    }
<span class="fc" id="L190">  }</span>

  private void parseLexFile(File lexFile) throws MojoFailureException, MojoExecutionException {
<span class="pc bpc" id="L193" title="2 of 4 branches missed.">    assert lexFile.isAbsolute() : lexFile;</span>

<span class="fc" id="L195">    getLog().debug(&quot;Generating Java code from &quot; + lexFile.getName());</span>
<span class="fc" id="L196">    SpecInfo specInfo = findSpecInfo(lexFile);</span>

<span class="fc" id="L198">    checkParameters(lexFile);</span>

    // set destination directory
<span class="fc" id="L201">    File generatedFile = new File(outputDirectory, specInfo.getOutputFilename());</span>

    // generate only if needs to
<span class="fc" id="L204">    long generatedLastModified = generatedFile.lastModified();</span>
<span class="pc bpc" id="L205" title="1 of 2 branches missed.">    if (lexFile.lastModified() - generatedLastModified &lt;= this.staleMillis</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">        &amp;&amp; latestModified(specInfo.includedFiles) - generatedLastModified &lt;= this.staleMillis) {</span>
<span class="nc" id="L207">      getLog().info(&quot;  &quot; + generatedFile.getName() + &quot; is up to date.&quot;);</span>
<span class="nc" id="L208">      getLog().debug(&quot;StaleMillis = &quot; + staleMillis + &quot;ms&quot;);</span>
<span class="nc" id="L209">      return;</span>
    }

    // set options. Very strange that JFlex expects this in a static way.
<span class="fc" id="L213">    OptionUtils.setDefaultOptions();</span>
<span class="fc" id="L214">    OptionUtils.setDir(generatedFile.getParentFile());</span>
<span class="fc" id="L215">    Options.setRootDirectory(project.getBasedir());</span>
<span class="fc" id="L216">    Options.dump = dump;</span>
<span class="fc" id="L217">    Options.verbose = verbose;</span>
<span class="fc" id="L218">    Options.unused_warning = unusedWarning;</span>
<span class="fc" id="L219">    Options.dot = dot;</span>
<span class="fc" id="L220">    Options.legacy_dot = legacyDot;</span>
<span class="pc bpc" id="L221" title="1 of 2 branches missed.">    if (skeleton != null) {</span>
<span class="nc" id="L222">      OptionUtils.setSkeleton(skeleton);</span>
    }
<span class="fc" id="L224">    Options.jlex = jlex;</span>

<span class="pc bpc" id="L226" title="1 of 2 branches missed.">    Options.no_minimize = !minimize; // NOPMD</span>
<span class="pc bpc" id="L227" title="1 of 2 branches missed.">    Options.no_backup = !backup; // NOPMD</span>
<span class="pc bpc" id="L228" title="1 of 2 branches missed.">    if (!Objects.equals(&quot;pack&quot;, generationMethod)) {</span>
<span class="nc" id="L229">      throw new MojoExecutionException(&quot;Illegal generation method: &quot; + generationMethod);</span>
    }

<span class="pc bpc" id="L232" title="1 of 2 branches missed.">    if (!isNullOrEmpty(encodingName)) {</span>
      try {
<span class="nc" id="L234">        OptionUtils.setEncoding(encodingName);</span>
<span class="nc" id="L235">      } catch (Exception e) {</span>
<span class="nc" id="L236">        throw new MojoExecutionException(e.getMessage());</span>
<span class="nc" id="L237">      }</span>
    }

    try {
<span class="fc" id="L241">      new LexGenerator(lexFile).generate();</span>
<span class="fc" id="L242">      getLog().info(&quot;  generated &quot; + generatedFile);</span>
<span class="nc" id="L243">    } catch (Exception e) {</span>
<span class="nc" id="L244">      throw new MojoExecutionException(e.getMessage(), e);</span>
<span class="fc" id="L245">    }</span>
<span class="fc" id="L246">  }</span>

  private SpecInfo findSpecInfo(File lexFile) throws MojoFailureException {
    try {
<span class="fc" id="L250">      return LexSimpleAnalyzerUtils.guessSpecInfo(lexFile);</span>
<span class="nc" id="L251">    } catch (FileNotFoundException e) {</span>
<span class="nc" id="L252">      throw new MojoFailureException(e.getMessage(), e);</span>
<span class="nc" id="L253">    } catch (IOException e) {</span>
<span class="nc" id="L254">      return new SpecInfo(LexSimpleAnalyzerUtils.DEFAULT_NAME, /*packageName=*/ &quot;&quot;);</span>
    }
  }

  /**
   * Check parameter lexFile.
   *
   * &lt;p&gt;Must not be {@code null} and file must exist.
   *
   * @param lexFile input file to check.
   * @throws MojoExecutionException in case of error
   */
  private void checkParameters(File lexFile) throws MojoExecutionException {
<span class="pc bpc" id="L267" title="1 of 2 branches missed.">    if (lexFile == null) {</span>
<span class="nc" id="L268">      throw new MojoExecutionException(</span>
          &quot;&lt;lexDefinition&gt; is empty. Please define input file with&quot;
              + &quot; &lt;lexDefinition&gt;input.jflex&lt;/lexDefinition&gt;&quot;);
    }
<span class="pc bpc" id="L272" title="1 of 2 branches missed.">    if (!lexFile.isFile()) {</span>
<span class="nc" id="L273">      throw new MojoExecutionException(&quot;Input file does not exist: &quot; + lexFile);</span>
    }
<span class="fc" id="L275">  }</span>

  /**
   * Converts the specified path argument into an absolute path. If the path is relative like
   * &quot;src/main/jflex&quot;, it is resolved against the base directory of the project (in constrast,
   * File.getAbsoluteFile() would resolve against the current directory which may be different,
   * especially during a reactor build).
   *
   * @param path The path argument to convert, may be {@code null}.
   * @return The absolute path corresponding to the input argument.
   */
  private File getAbsolutePath(File path) {
<span class="pc bpc" id="L287" title="2 of 4 branches missed.">    if (path == null || path.isAbsolute()) {</span>
<span class="nc" id="L288">      return path;</span>
    }
<span class="fc" id="L290">    return new File(this.project.getBasedir().getAbsolutePath(), path.getPath());</span>
  }

  /**
   * Determines the highest {@link File#lastModified()} value among the specified {@code
   * includedFiles}, which are resolved relative to the specified {@code parent} directory.
   *
   * @return the latest value -- or 0 if the list is empty, if no files exist, or if I/O exceptions
   *     prevent getting any values
   */
  private static long latestModified(Set&lt;File&gt; includedFiles) {
<span class="nc" id="L301">    long result = 0;</span>
<span class="nc bnc" id="L302" title="All 2 branches missed.">    for (File file : includedFiles) {</span>
<span class="nc" id="L303">      result = Math.max(file.lastModified(), result);</span>
<span class="nc" id="L304">    }</span>
<span class="nc" id="L305">    return result;</span>
  }

  static class ExtensionPredicate implements Predicate&lt;File&gt; {
    final ImmutableSet&lt;String&gt; extensions;

<span class="fc" id="L311">    ExtensionPredicate(ImmutableSet&lt;String&gt; extensions) {</span>
<span class="fc" id="L312">      this.extensions = extensions;</span>
<span class="fc" id="L313">    }</span>

    ExtensionPredicate(String... extensions) {
<span class="fc" id="L316">      this(ImmutableSet.copyOf(extensions));</span>
<span class="fc" id="L317">    }</span>

    @Override
    public boolean apply(File file) {
<span class="fc" id="L321">      return extensions.contains(Files.getFileExtension(file.getName()));</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>